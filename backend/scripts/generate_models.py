import re
import json
import os
from pathlib import Path

# Paths
BASE_DIR = Path(__file__).resolve().parent.parent.parent
FRONTEND_PARAMS_PATH = BASE_DIR / "frontend/src/constants/parameters.js"
BACKEND_OUTPUT_PATH = BASE_DIR / "backend/app/schemas/configuration_auto.py"

def parse_js_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # Regex to find the PARAMETERS object
    # We look for "export const PARAMETERS = {" and capture until the matching closing brace
    # This is a bit "heuristic" but works for structured files like this.
    
    # Strategy: Extract the block, then parse key by key.
    # Because valid JS isn't always valid JSON, we'll use regex to find definitions.
    
    parameter_pattern = re.compile(r"(\w+):\s*\{([^}]+)\}", re.MULTILINE | re.DOTALL)
    
    parameters = {}
    
    matches = parameter_pattern.finditer(content)
    
    for match in matches:
        param_name = match.group(1)
        body = match.group(2)
        
        # Extract Key
        key_match = re.search(r"key:\s*['\"](\w+)['\"]", body)
        if not key_match: continue
        key = key_match.group(1)
        
        # Extract Type
        type_match = re.search(r"type:\s*['\"](\w+)['\"]", body)
        param_type = type_match.group(1) if type_match else "string"
        
        # Extract Required
        req_match = re.search(r"required:\s*(true|false)", body)
        required = req_match.group(1) == "true" if req_match else False
        
        # Extract Validation
        min_match = re.search(r"min:\s*([0-9.]+)", body)
        max_match = re.search(r"max:\s*([0-9.]+)", body)
        
        parameters[key] = {
            "type": param_type,
            "required": required,
            "min": float(min_match.group(1)) if min_match else None,
            "max": float(max_match.group(1)) if max_match else None
        }
        
    return parameters

def generate_python_code(params):
    lines = [
        "# AUTO-GENERATED FILE - DO NOT EDIT",
        "# Generated by backend/scripts/generate_models.py",
        "",
        "from pydantic import BaseModel, Field",
        "from typing import Optional",
        "",
        "class AutoGeneratedParameters(BaseModel):"
    ]
    
    for key, data in params.items():
        py_type = "float" if data["type"] == "number" else "str"
        
        field_args = []
        if data["min"] is not None:
            field_args.append(f"ge={data['min']}")
        if data["max"] is not None:
            field_args.append(f"le={data['max']}")
            
        field_args_str = ", ".join(field_args)
        if field_args_str:
            field_args_str = ", " + field_args_str
            
        if data["required"]:
            line = f"    {key}: {py_type} = Field(...{field_args_str})"
        else:
            line = f"    {key}: Optional[{py_type}] = Field(None{field_args_str})"
            
        lines.append(line)
        
    return "\n".join(lines)

def main():
    print(f"Reading from {FRONTEND_PARAMS_PATH}...")
    if not FRONTEND_PARAMS_PATH.exists():
        print("Error: Frontend parameters file not found!")
        return

    params = parse_js_file(FRONTEND_PARAMS_PATH)
    print(f"Found {len(params)} parameters.")
    
    code = generate_python_code(params)
    
    print(f"Writing to {BACKEND_OUTPUT_PATH}...")
    with open(BACKEND_OUTPUT_PATH, 'w', encoding='utf-8') as f:
        f.write(code)
        
    print("Done!")

if __name__ == "__main__":
    main()
